---
title: "Amplitude Inference via Bootstrap SCB"
output: html_document
date: "2025-11-25"
---

```{r scb comparaison}

Bootstrap_scb_difference <- function(fd_group1, fd_group2, n_bootstrap, Time) {
  
  eps <- 1e-6  # small stabilizer
  
  n1 <- dim(fd_group1$coefs)[2]
  n2 <- dim(fd_group2$coefs)[2]
  

  # === 1. Observed mean curves ===
  mean1 <- eval.fd(Time, mean.fd(fd_group1))
  mean2 <- eval.fd(Time, mean.fd(fd_group2))
  diff_mean <- mean1 - mean2
  

  # === 2. SAFE variance estimator ===
  safe_variance_fd <- function(fd_group) {
    n_subj <- dim(fd_group$coefs)[2]
    
    # fallback if n is too small
    if (n_subj < 3) {
      raw_curves <- eval.fd(Time, fd_group)
      v <- apply(raw_curves, 1, var)
      return(v + eps)
    }
    
    pca_res <- try(pca.fd(fd_group, nharm = 2), silent = TRUE)
    
    if (inherits(pca_res, "try-error") || any(is.na(pca_res$values[1:2]))) {
      # FPCA failed â†’ fallback
      raw_curves <- eval.fd(Time, fd_group)
      v <- apply(raw_curves, 1, var)
      return(v + eps)
    }
    
    harm <- eval.fd(Time, pca_res$harmonics)
    eig  <- pca_res$values[1:2]
    
    var_fpca <- rowSums((harm^2) %*% diag(eig))
    return(var_fpca + eps)
  }
  

  var1 <- safe_variance_fd(fd_group1)
  var2 <- safe_variance_fd(fd_group2)
  
  var_sum <- sqrt(var1 + var2)
  

  # === 3. Observed sup statistic ===
  Z_obs <- sqrt(n1 + n2) * diff_mean / var_sum
  Z_obs[!is.finite(Z_obs)] <- 0  # protect
  
  T_obs <- max(abs(Z_obs))
  

  # === 4. Bootstrap ===
  supremums <- rep(NA, n_bootstrap)
  
  for (b in seq_len(n_bootstrap)) {
    
    idx1 <- sample(seq_len(n1), n1, replace = TRUE)
    idx2 <- sample(seq_len(n2), n2, replace = TRUE)
    
    fd1_b <- fd(fd_group1$coefs[, idx1], fd_group1$basis)
    fd2_b <- fd(fd_group2$coefs[, idx2], fd_group2$basis)
    
    mean1_b <- eval.fd(Time, mean.fd(fd1_b))
    mean2_b <- eval.fd(Time, mean.fd(fd2_b))
    diff_b  <- mean1_b - mean2_b
    
    var1_b <- safe_variance_fd(fd1_b)
    var2_b <- safe_variance_fd(fd2_b)
    var_b  <- sqrt(var1_b + var2_b)
    
    Z_b <- sqrt(n1 + n2) * (diff_b - diff_mean) / var_b
    Z_b[!is.finite(Z_b)] <- 0
    
    supremums[b] <- max(abs(Z_b))
  }
  
  # remove NA
  supremums <- supremums[is.finite(supremums)]

  if (length(supremums) < 50) {
    warning("Bootstrap produced too many NaN iterations!")
  }
  
  z_alpha <- quantile(supremums, 0.95)
  

  lower <- diff_mean - (z_alpha * var_sum) / sqrt(n1 + n2)
  upper <- diff_mean + (z_alpha * var_sum) / sqrt(n1 + n2)
  

  # === 6. Cohen's d ===
  sd_pooled <- sqrt((var1 + var2) / 2)
  d_curve <- diff_mean / sd_pooled
  d_curve[!is.finite(d_curve)] <- 0
  
  d_t <- diff_mean / var_sum
  d_t[!is.finite(d_t)] <- 0

  d_mean <- mean(abs(d_curve))
  d_max <- max(abs(d_curve))
  

  # === 7. Output ===
  list(
    mean = diff_mean,
    lower = lower,
    upper = upper,
    
    sup_obs = T_obs,
    sup_dist = supremums,
    z_alpha = z_alpha,

    p_value = (1 + sum(supremums >= T_obs)) / (length(supremums) + 1),
    
    d_curve = d_curve,
    d_t = d_t,
    d_max = d_max,
    d_mean = d_mean
  )
}

```


