---
title: "FDA male female HRM WT juv"
output: html_document
date: "2025-04-29"
---



### A Functional Data Analysis Pipeline for Electrophysiological Time-Series (fEPSP % of baseline)




## data preparation

```{r}
library(fda)
library(fda.usc)
library(readxl)
library(dplyr)
library(tidyr)
library(fdANOVA)



data_juv <- read_excel("C:/Users/bs/Desktop/salma/pipline/all data.xlsx", sheet = "juv")
data_ado <- read_excel("C:/Users/bs/Desktop/salma/pipline/all data.xlsx", sheet = "ado")
data_adu <- read_excel("C:/Users/bs/Desktop/salma/pipline/all data.xlsx", sheet = "adu")
data_age <- read_excel("C:/Users/bs/Desktop/salma/pipline/all data.xlsx", sheet = "age")


clean_data <- function(data, time_min, time_max, drop_cols) {
  data <- data[, -drop_cols]
  colnames(data) <- as.character(unlist(data[5, ]))
  data <- data[-c(1:6), ]
  colnames(data)[1] <- "Time"
  data$Time <- as.numeric(data$Time)
  data[-1] <- lapply(data[-1], as.numeric)
  
  data %>%
    filter(Time >= time_min & Time <= time_max) %>%
    filter(complete.cases(.))
}



cleaned_data_juv <- clean_data(data_juv, 10, 2400, c(1:4,6,15,26:32,43,44))
cleaned_data_ado <- clean_data(data_ado, 10, 2390, c(1:4,16,23,26,37))
cleaned_data_adu <- clean_data(data_adu, 10, 2390, c(1:4,6,11,17,20,28,29,36,38))
cleaned_data_age <- clean_data(data_adu, 10, 2400, c())

Time <- cleaned_data_juv$Time

matrix_juv <- as.matrix(cleaned_data_juv[, -1]) 
matrix_ado <- as.matrix(cleaned_data_ado[, -1]) 
matrix_adu <- as.matrix(cleaned_data_adu[, -1]) 
matrix_age <- as.matrix(cleaned_data_age[, -1])



#-----------------------------Juvenile group-----------------------------------------

malesWTjuv_gp <- matrix_juv[,  1:8]           #male
malesHRMjuv_gp <- matrix_juv[, 9:18]          #male
femalesWTjuv_gp <- matrix_juv[, 19:28]        #female
femalesHRMjuv_gp <- matrix_juv[, 29:40]       #female

#-----------------------------Adolescent group-----------------------------------------

malesWTado_gp <- matrix_ado[, 1:10]            #male
malesHRMado_gp <- matrix_ado[, 11:18]          #male
femalesWTado_gp <- matrix_ado[, 19:28]         #female
femalesHRMado_gp<- matrix_ado[, 29:37]         #female


#-----------------------------Adult group-----------------------------------------

malesWTadu_gp <- matrix_adu[,1:9]           #male
malesHRMadu_gp <- matrix_adu[, 10:18]       #male
femalesWTadu_gp <- matrix_adu[,19:25]        #female
femalesHRMadu_gp <- matrix_adu[,]       #female

#-----------------------------Aged group-----------------------------------------

malesWTage_gp <- matrix_age[, ]            #male
malesHRMage_gp <- matrix_age[, ]          #male
femalesWTage_gp <- matrix_age[, ]         #female
femalesHRMage_gp<- matrix_age[, ]         #female

```




## Mean and SEM organised by sexe and dev stade

```{r}
# Préparation des données
#x <- 1:nrow(malesHRMjuv_gp)
x<- Time

groups <- list(
  
   #-----------------------Mean Males------------------------------------
   
  males_juv = list(
    malesWTjuv = rowMeans(malesWTjuv_gp),        #juvenile
    malesHRMjuv = rowMeans(malesHRMjuv_gp)),
  
  males_ado = list(
    malesWTado = rowMeans(malesWTado_gp),        #adolescent
    malesHRMado = rowMeans(malesHRMado_gp)),
  
  males_adu = list(
    malesWTadu = rowMeans(malesWTadu_gp),        #adult
    malesHRMadu = rowMeans(malesHRMadu_gp)),    
  
  males_age = list(
    malesWTage = rowMeans(malesWTage_gp),         #aged
    malesHRMage = rowMeans(malesHRMage_gp)),
  
  
  
  
   #---------------------------Mean Females---------------------------------
  
  females_juv = list(
    femalesWTjuv = rowMeans(femalesWTjuv_gp),         #juvenile
    femalesHRMjuv = rowMeans(femalesHRMjuv_gp)),    
  
  females_ado = list(
    femalesWTado = rowMeans(femalesWTado_gp),        #adolescent
    femalesHRMado = rowMeans(femalesHRMado_gp)),    
  
  females_adu = list(
    femalesWTadu = rowMeans(femalesWTadu_gp),         #adult
    femalesHRMadu = rowMeans(femalesHRMadu_gp)),
  
  females_age = list(
    femalesWTage = rowMeans(femalesWTage_gp),          #aged
    femalesHRMage = rowMeans(femalesHRMage_gp))
  
)

sems <- list(
  
    #-----------------------Sem Males------------------------------------
    
  males_juv = list(
    malesHRMjuv = apply(malesHRMjuv_gp, 1, sd) / sqrt(ncol(malesHRMjuv_gp)),
    malesWTjuv = apply(malesWTjuv_gp, 1, sd) / sqrt(ncol(malesWTjuv_gp))),
  
  
  males_ado = list(
    malesHRMado = apply(malesHRMado_gp, 1, sd) / sqrt(ncol(malesHRMado_gp)),
    malesWTado = apply(malesWTado_gp, 1, sd) / sqrt(ncol(malesWTado_gp))),
  
  males_adu = list(
    malesHRMadu = apply(malesHRMadu_gp, 1, sd) / sqrt(ncol(malesHRMadu_gp)),
    malesWTadu = apply(malesWTadu_gp, 1, sd) / sqrt(ncol(malesWTadu_gp))),
  
  males_age = list(
    malesHRMage = apply(malesHRMage_gp, 1, sd) / sqrt(ncol(malesHRMage_gp)),
    malesWTage = apply(malesWTage_gp, 1, sd) / sqrt(ncol(malesWTage_gp))),
  
  
    #----------------------- Sem Females------------------------------------
  
  females_juv = list(
    femalesHRMjuv = apply(femalesHRMjuv_gp, 1, sd) / sqrt(ncol(femalesHRMjuv_gp)),
    femalesWTjuv = apply(femalesWTjuv_gp, 1, sd) / sqrt(ncol(femalesWTjuv_gp))),
  
  
  females_ado = list(
    femalesHRMado = apply(femalesHRMado_gp, 1, sd) / sqrt(ncol(femalesHRMado_gp)),
    femalesWTado = apply(femalesWTado_gp, 1, sd) / sqrt(ncol(femalesWTado_gp))),
  
  females_adu = list(
    femalesHRMadu = apply(femalesHRMadu_gp, 1, sd) / sqrt(ncol(femalesHRMadu_gp)),
    femalesWTadu = apply(femalesWTadu_gp, 1, sd) / sqrt(ncol(femalesWTadu_gp))),
  
  females_age = list(
    femalesHRMage = apply(femalesHRMage_gp, 1, sd) / sqrt(ncol(femalesHRMage_gp)),
    femalesWTage = apply(femalesWTage_gp, 1, sd) / sqrt(ncol(femalesWTage_gp)))
  
  
)


pcolors <- c(
  malesWTjuv = "cyan3",malesHRMjuv = "royalblue",
  
  malesWTado = "steelblue3",malesHRMado = "blue4",    
  
  malesWTadu = "orange",malesHRMadu = "orange4",
  
  malesWTage = "green3",malesHRMage = "green4", 
  
  
  femalesWTjuv = "magenta2",femalesHRMjuv = "darkviolet",
  
  femalesWTado = "orchid",femalesHRMado = "purple4",
  
  femalesWTadu = "yellow2",femalesHRMadu = "yellow4",
  
  femalesWTage = "red",femalesHRMage = "red4",
  
  
)



#par(mfrow = c(2, 2))

for (group_name in names(groups)) {
  curves <- groups[[group_name]]
  errors <- sems[[group_name]]
  
  ylims <- range(mapply(function(m, s) c(m - s, m + s), curves, errors))
  
  plot(x, curves[[1]], type = "n", ylim = ylims,
       xlab = "Time(sec)", ylab = "fEPSP", 
       main = bquote("mean" %+-% "SEM -" ~ .(gsub("_", " ", group_name))))

  
  for (curve_name in names(curves)) {
    lines(x, curves[[curve_name]], col = pcolors[[curve_name]], lwd = 2)
    arrows(x, curves[[curve_name]] - errors[[curve_name]],
           x, curves[[curve_name]] + errors[[curve_name]],
           angle = 90, code = 3, length = 0.02, col = pcolors[[curve_name]])
  }
  
  legend("topleft", legend = names(curves), col = pcolors[names(curves)], 
         lwd = 2, bty = "n", cex = 1.2)
}

par(mfrow = c(1, 1))  # Réinitialisation


```



##Smoothing: B-spline basis (degree 3), penalized least squares, $\lambda$ by GCV

```{r}
Common_smoothing <- function(all_data_groups, Time) {
  # Combine all groups to get the global raw mean
  all_data_combined <- do.call(cbind, all_data_groups)
  y_mean_global_raw <- rowMeans(all_data_combined, na.rm = TRUE)

  # Temporary B-spline basis just to smooth y_mean_global_raw
  nbasis_smooth <- 4
  norder_smooth <- 4
  basis_smooth <- create.bspline.basis(rangeval = range(Time), nbasis = nbasis_smooth, norder = norder_smooth)

  #  lambda manually to avoid over-smoothing
  lambda_opt_smooth <- 8
  fdPar_obj_smooth <- fdPar(basis_smooth, Lfdobj = 2, lambda = lambda_opt_smooth)
  smooth_global <- smooth.basis(Time, y_mean_global_raw, fdPar_obj_smooth)
  y_mean_global <- eval.fd(Time, smooth_global$fd)

  # Compute second derivative to guide knot placement
  dy <- diff(y_mean_global) / diff(Time)
  d2y <- diff(dy) / diff(Time[-1])
  second_deriv <- c(d2y[1], d2y, tail(d2y, 1))
  weight <- abs(second_deriv)
  weight <- weight / sum(weight, na.rm = TRUE)

  # Define knots using weighted quantiles
  nbasis <- 12
  norder <- 4
  nbreaks <- nbasis - norder + 2
  cum_weight <- cumsum(weight) / sum(weight)
  quantiles <- seq(0, 1, length.out = nbreaks + 2)[-c(1, nbreaks + 2)]
  break_indices <- sapply(quantiles, function(q) which.min(abs(cum_weight - q)))
  nodes <- unique(c(min(Time), Time[break_indices], max(Time)))
  grid <- seq(min(Time), max(Time), length.out = 200)

  # Final common basis for all smoothing
  basis <- create.bspline.basis(rangeval = range(grid), norder = norder, breaks = nodes)

  # Global lambda selection (again) for actual smoothing of each curve
  lambda_values <- 10^seq(-1, 3, length.out = 300)
  gcv <- sapply(lambda_values, function(lambda) {
    fdPar_obj <- fdPar(basis, Lfdobj = 2, lambda = lambda)
    smooth <- smooth.basis(Time, y_mean_global, fdPar_obj)
    mean(smooth$gcv, na.rm = TRUE)
  })
  lambda_opt <- lambda_values[which.min(gcv)]

  # Smooth each curve in each group using common basis + common lambda
  fd_group_list <- lapply(all_data_groups, function(data_group) {
    coefs_list <- list()
    for (i in 1:ncol(data_group)) {
      fit_interp <- approx(Time, data_group[, i], xout = grid)$y
      fdPar_obj <- fdPar(basis, Lfdobj = 2, lambda = lambda_opt)
      smooth_fd <- smooth.basis(grid, fit_interp, fdPar_obj)$fd
      coefs_list[[i]] <- smooth_fd$coefs
    }
    coefs_mat <- do.call(cbind, coefs_list)
    fd_obj <- fd(coef = coefs_mat, basisobj = basis)
    return(fd_obj)
  })

  # Return everything
  return(list(
    fd_list = fd_group_list,
    lambda_opt = lambda_opt,
    lambda_values = lambda_values,
    gcv = gcv,
    nodes = nodes,
    basis = basis,
    lambda_opt_smooth = lambda_opt_smooth
  ))
}

```



## Applying the function common smoothing


```{r}

#all discrete curves for each group
all_groups <- list(
  malesWTjuv = malesWTjuv_gp,
  malesHRMjuv = malesHRMjuv_gp,
  femalesWTjuv = femalesWTjuv_gp,
  femalesHRMjuv = femalesHRMjuv_gp,  #juv
  
  malesWTado = malesWTado_gp,
  malesHRMado = malesHRMado_gp,
  femalesWTado = femalesWTado_gp,
  femalesHRMado = femalesHRMado_gp,  #ado
  
  malesWTadu = malesWTadu_gp,
  malesHRMadu = malesHRMadu_gp,
  femalesWTadu = femalesWTadu_gp
  #femalesHRMadu_gp,  #adu
  
  #malesWTage_gp,malesHRMage_gp,femalesWTage_gp,femalesHRMage_gp,  #age
)

#applying the common smothing
result_common <- Common_smoothing(all_groups, Time)

#-----------------------------juv group-----------------------------------------

malesWTjuv_fd      <- result_common$fd_list$malesWTjuv
malesHRMjuv_fd     <- result_common$fd_list$malesHRMjuv
femalesWTjuv_fd    <- result_common$fd_list$femalesWTjuv
femalesHRMjuv_fd   <- result_common$fd_list$femalesHRMjuv

#-----------------------------ado group-----------------------------------------
malesWTado_fd      <- result_common$fd_list$malesWTado
malesHRMado_fd     <- result_common$fd_list$malesHRMado
femalesWTado_fd    <- result_common$fd_list$femalesWTado
femalesHRMado_fd   <- result_common$fd_list$femalesHRMado


#-----------------------------adu group-----------------------------------------
malesWTadu_fd      <- result_common$fd_list$malesWTadu
malesHRMadu_fd     <- result_common$fd_list$malesHRMadu
femalesWTadu_fd    <- result_common$fd_list$femalesWTadu
#femalesHRMadu_fd   <- result_common$fd_list$femalesHRMadu


#-----------------------------age group-----------------------------------------
#malesWTage_fd      <- result_common$fd_list$malesWTage
#malesHRMage_fd     <- result_common$fd_list$malesHRMage
#femalesWTage_fd    <- result_common$fd_list$femalesWTage
#femalesHRMage_fd   <- result_common$fd_list$femalesHRMage

```



##plots: Continous curves for each group.

```{r}

print(result_common$lambda_opt)   #optimal lambda (common smoothing parameter)
plot(result_common$lambda_values, result_common$gcv, xlab="lambda", ylab="gcv") #  
print(result_common$nodes) #common knots placement
plot(result_common$basis, xlab= "Time", lty=1, lwd=2,main="Spline Basis Functions") # common spline basis function graph  
#----------------------------------------------------------------------------

groups_names <- c(
  "Males WT Juvenile","males HRM Juvenile","Females WT Juvenile","Females HRM Juvenile",
  
  "Males WT Adolescent","Males HRM Adolescent","Females WT Adolescent","Females HRM Adolescent",
  
  "Males WT Adult","Males HRM Adult","Females WT Adult" #"Females HRM Adult",
  
  #"Males WT Aged",#"Males HRM Aged",#"Females WT Aged,#"Females HRM Aged"
)  


colors <- c(
  # Juvenile - BLUE family
   "#00427A",  "#00427A",  "#4F8FD3",  "#4F8FD3",  

  # Adolescent - ORANGE family
   "yellow3", "yellow3",  "#DC5700",  "#DC5700",  

  # Adult - GREEN family
   "green3","green3","#1F7F1F" #"#1F7F1F", 

  # Aged - PURPLE family
   #"#A463C3",#"#A463C3", #"red3",#"red3"
  
)   


lty <- c(1,2,1,2, 1,2,1,2, 1,2,1 #2,#1,2,1,2
         )


#-------------------------Plot group's curves----------------------------------------------------


plot_gp_curves <- function(fd_gp, title_gp, col, lty,
                         ylim_global = NULL) {
  
  
  grid <- seq(min(Time), max(Time), length.out = 200)
  mat  <- eval.fd(grid, fd_gp)    
  
  # Since global limit is not given we compute it to get the scale 
  if (is.null(ylim_global)) {
    ylim_global <- range(mat)
  }
  
  #first curves
  plot(grid, mat[, 1],type='l', col = col,lty=lty, lwd = 2,
       main = title_gp, xlab = "Time (sec)", ylab = "fESPS % of baseline",
       ylim = ylim_global)
  
  #adding the other curves of the group
  if (ncol(mat) > 1) {
    for (i in 2:ncol(mat)) {
      lines(grid, mat[, i],lty= lty, col = col, lwd = 2)
    }
  }
}


# fd group list
all_fd <- list(
  
   #-----------------------------juv group---------------------
  malesWTjuv_fd,malesHRMjuv_fd,
  femalesWTjuv_fd,femalesHRMjuv_fd,
  
  #-----------------------------ado group----------------------
  
  malesWTado_fd,malesHRMado_fd,    
  femalesWTado_fd,femalesHRMado_fd,
  
  #-----------------------------adu group----------------------
  
  malesWTadu_fd,malesHRMadu_fd,
  femalesWTadu_fd #femalesHRMadu_fd,
  
  #-----------------------------age group-----------------------
  
  #malesWTadu_fd, #malesHRMadu_fd,
  #femalesWTadu_fd,#femalesHRMadu_fd,
  
)


# computing global limit ylim_global
grid <- seq(min(Time), max(Time), length.out = 200)

all_vals <- unlist(
  lapply(all_fd, function(fd) eval.fd(grid, fd))
)

ylim_global <- range(all_vals)

for (i in 1:length(all_fd)) {
  plot_gp_curves(
    fd_gp = all_fd[[i]],
    title_gp = groups_names[i],
    col = colors[i],
    lty =lty[i],
    ylim_global = ylim_global
    
    
  )
  abline(h = 150, col = "black", lwd = 2, lty = 2)
  grid()
}

```


## Residuals study: the empirical residual distribution.

```{r}
compute_residuals <- function(original_group, fd_object, time_points) {
  smoothed <- eval.fd(time_points, fd_object)
  residuals <- original_group - smoothed
  return(residuals)
}


group_names <- c(
  "malesWTjuv", "malesHRMjuv", "femalesWTjuv", "femalesHRMjuv",
  "malesWTado", "malesHRMado", "femalesWTado", "femalesHRMado",
  "malesWTadu", "malesHRMadu", "femalesWTadu", "femalesHRMadu",
  "malesWTage", "malesHRMage", "femalesWTage", "femalesHRMage"
  
)

original_groups <- list(
  malesWTjuv_gp, malesHRMjuv_gp, femalesWTjuv_gp, femalesHRMjuv_gp,
  malesWTado_gp, malesHRMado_gp, femalesWTado_gp, femalesHRMado_gp,
  malesWTadu_gp, malesHRMadu_gp, femalesWTadu_gp, femalesHRMadu_gp,
  malesWTage_gp, malesHRMage_gp, femalesWTage_gp, femalesHRMage_gp
)

par(mfrow = c(2, 3))
smoothed_fds <- result_common$fd_list
acf_results_list <- list()

for (i in seq_along(group_names)) {
  nom <- group_names[i]
  group_data <- original_groups[[i]]
  fd_obj <- smoothed_fds[[i]]
  
  # Compute residuals
  residus <- compute_residuals(group_data, fd_obj, Time)
  
  plot(Time, residus[,1], main = paste("residuals -", nom), xlab = "Time(sec)")
  
  # Histogramme
  hist(as.vector(residus), breaks = 30, col = "lightblue",
       main = paste("Histogramme -", nom), xlab = "Residuals")
  
  # QQ-plot
  qqnorm(as.vector(residus), main = paste("QQ-Plot -", nom))
  qqline(as.vector(residus), col = "red")
  
  # Compute ACF
  # ACF globale
  acf(as.vector(residus), main = paste("ACF globale -", nom), plot=FALSE)
  
  
  rho_HA <- estimer_rho_groupe(residus)
  cat("mean empirical rho -", nom, ": rho =", round(rho_HA, 4), "\n")
}

```


##Outlier handling: At the local level

```{r}

Local_outlier <- function(group_data, smooth_fd_object, Time, alpha = 0.05) {
  group_data <- as.matrix(group_data)
  group_data <- apply(group_data, 2, as.numeric)

  # Shared basis and lambda
  basis_obj <- smooth_fd_object$basis
  lambda <- smooth_fd_object$lambda_opt
  fdPar_group <- fdPar(basis_obj, Lfdobj = int2Lfd(2), lambda = lambda)

  imputed_data <- group_data

  nbasis <- basis_obj$nbasis
  n <- length(Time)
  df <- n - nbasis  # degrees of freedom for residuals

  # Student-t quantile
  t_quantile <- qt(1 - alpha / 2, df = max(df, 1))  # avoid df <= 0

  for (i in seq_len(ncol(group_data))) {
    # Step 1: Smooth the curve
    fd_i <- smooth.basis(Time, group_data[, i], fdPar_group)$fd
    predicted_i <- eval.fd(Time, fd_i)

    # Step 2: Residuals and outlier detection
    residuals <- group_data[, i] - predicted_i
    sigma_hat <- sd(residuals, na.rm = TRUE)
    threshold <- t_quantile * sigma_hat
    outliers <- abs(residuals) > threshold

    # Step 3: Re-smooth using only non-outlier points
    filtered_idx <- which(!outliers)
    if (length(filtered_idx) > 10) {
      fd_clean <- smooth.basis(
        argvals = Time[filtered_idx],
        y = group_data[filtered_idx, i],
        fdParobj = fdPar_group
      )$fd

      # Step 4: Impute the outlier values
      imputed_values <- eval.fd(Time[outliers], fd_clean)
      imputed_data[outliers, i] <- imputed_values
    }
  }

  # Final smoothing on imputed data
  final_fd <- smooth.basis(Time, imputed_data, fdPar_group)$fd

  return(list(
    fd = final_fd,
    lambda = lambda,
    basis = basis_obj,
    imputed_data = imputed_data,
    alpha = alpha
  ))
}

```


## plots: comparaison between the smoothed curves and the same curves handled by the local approach.

```{r}
cleaned_results <- lapply(all_groups, function(group) {
  Local_outlier(group, result_common, Time)
})

#-----------------------------juv group-----------------------------------------

cleaned_malesWTjuv     <- cleaned_results[[1]]
cleaned_malesHRMjuv    <- cleaned_results[[2]]
cleaned_femalesWTjuv   <- cleaned_results[[3]]
cleaned_femalesHRMjuv  <- cleaned_results[[4]]

#-----------------------------ado group-----------------------------------------

cleaned_malesWTado     <- cleaned_results[[5]]
cleaned_malesHRMado    <- cleaned_results[[6]]
cleaned_femalesWTado   <- cleaned_results[[7]]
cleaned_femalesHRMado  <- cleaned_results[[8]]

#-----------------------------adu group-----------------------------------------

cleaned_malesWTadu     <- cleaned_results[[9]]
cleaned_malesHRMadu    <- cleaned_results[[10]]
cleaned_femalesWTadu   <- cleaned_results[[11]]
cleaned_femalesHRMadu  <- cleaned_results[[12]]

#-----------------------------age group-----------------------------------------

cleaned_malesWTage     <- cleaned_results[[13]]
cleaned_malesHRMage    <- cleaned_results[[14]]
cleaned_femalesWTage   <- cleaned_results[[15]]
cleaned_femalesHRMage  <- cleaned_results[[16]]



plot_fd_comparison <- function(original_fd, cleaned_fd, Time, title_text,
                               original_col = "gray50", cleaned_col = "blue") {
  
  grid <- seq(min(Time), max(Time), length.out = 200)
  original_mat <- eval.fd(grid, original_fd)
  cleaned_mat <- eval.fd(grid, cleaned_fd$fd)

  # original smoothed curves in gray
  matplot(grid, original_mat, type = "l", col = original_col, lty = 1,lwd = 2,
          main = title_text,
          xlab = "Time(sec)", ylab = "fEPSP", ylim = range(c(original_mat, cleaned_mat)))

  # cleaned smoothed curves in color
  matlines(grid, cleaned_mat, col = cleaned_col, lty = 1, lwd = 1)

  
  #legend("topleft",legend = c("Original Smoothed", "Cleaned Smoothed"),col = c(original_col, cleaned_col),lty = 1, lwd = c(1, 2), bty = "n")
  grid()
}




#par(mfrow = c(1, 2))
#----------------------------- Juv-----------------------------------------
plot_fd_comparison(malesWTjuv_fd,    cleaned_malesWTjuv,     Time, "Males WT Juvenile ",    cleaned_col = "cyan3")
plot_fd_comparison(malesHRMjuv_fd,   cleaned_malesHRMjuv,    Time, "Males HRM Juvenile",   cleaned_col = "royalblue")
plot_fd_comparison(femalesWTjuv_fd,  cleaned_femalesWTjuv,   Time, "Females WT Juvenile",cleaned_col = "magenta2")
plot_fd_comparison(femalesHRMjuv_fd, cleaned_femalesHRMjuv,  Time, "Females HRM Juvenile",cleaned_col = "darkviolet")


#------------------------------ Ado--------------------------------------
plot_fd_comparison(malesWTado_fd,    cleaned_malesWTado,     Time, "Males WT Adolescent",  cleaned_col = "steelblue3")
plot_fd_comparison(malesHRMado_fd,   cleaned_malesHRMado,    Time, "Males HRM Adolescent", cleaned_col = "blue4")
plot_fd_comparison(femalesWTado_fd,  cleaned_femalesWTado,   Time, "Females WT Adolescent",cleaned_col = "orchid")
plot_fd_comparison(femalesHRMado_fd, cleaned_femalesHRMado,  Time, "Females HRM Adolescent",cleaned_col = "purple4")

#------------------------------ adu--------------------------------------
plot_fd_comparison(malesWTadu_fd,    cleaned_malesWTadu,     Time, "Males WT Adult",  cleaned_col = "orange")
plot_fd_comparison(malesHRMadu_fd,   cleaned_malesHRMadu,    Time, "Males HRM Adult", cleaned_col = "orange4")
plot_fd_comparison(femalesWTadu_fd,  cleaned_femalesWTadu,   Time, "Females WT Adult",cleaned_col = "yellow2")
plot_fd_comparison(femalesHRMadu_fd, cleaned_femalesHRMadu,  Time, "Females HRM Adult",cleaned_col = "yellow4")


#------------------------------ age--------------------------------------
plot_fd_comparison(malesWTage_fd,    cleaned_malesWTage,     Time, "Males WT Aged",  cleaned_col = "green3")
plot_fd_comparison(malesHRMage_fd,   cleaned_malesHRMage,    Time, "Males HRM Aged", cleaned_col = "green4")
plot_fd_comparison(femalesWTage_fd,  cleaned_femalesWTage,   Time, "Females WT Aged",cleaned_col = "red")
plot_fd_comparison(femalesHRMage_fd, cleaned_femalesHRMage,  Time, "Females HRM Aged",cleaned_col = "red4")

```





Outlier handling: At the global level.


```{r}
Time <- filtered_data_ado$Time
Global_outliers <- function(fd_group, Time) {
  
  values_matrix <- eval.fd(Time, fd_group)
  fdata_group <- fdata(values_matrix, argvals = Time)

  out_FM <- depth.FM(fdata_group, trim = 0.1)
  out_RT <- depth.RT(fdata_group, trim = 0.1)

  # Outlier thresholds
  seuil_FM <- quantile(out_FM$dep, probs = 0.1)
  seuil_RT <- quantile(out_RT$dep, probs = 0.1)

  # Outlier indices
  outliers_FM <- which(out_FM$dep <= seuil_FM)
  outliers_RT <- which(out_RT$dep <= seuil_RT)

  # Combine both
  outliers_final <- unique(c(outliers_FM, outliers_RT))

  return(outliers_final)
}
```


## plots: outlier curves among groups


```{r}
#cleaned_results <- lapply(all_groups, function(group) {
  #Global_outlier(group, result_common, Time)
#})


#-----------------------------juv-----------------------------------------
outliers_malesHRMjuv   <- Global_outliers(malesHRMjuv_fd, Time)
outliers_malesWTjuv    <- Global_outliers(malesWTjuv_fd, Time)
outliers_femalesHRMjuv   <- Global_outliers(femalesHRMjuv_fd, Time)
outliers_femalesWTjuv    <- Global_outliers(femalesWTjuv_fd, Time)

#-----------------------------ado-----------------------------------------
outliers_malesHRMado   <- Global_outliers(malesHRMado_fd, Time)
outliers_malesWTado    <- Global_outliers(malesWTado_fd, Time)
outliers_femalesWTado  <- Global_outliers(femalesWTado_fd, Time)
outliers_femalesHRMado <- Global_outliers(femalesHRMado_fd, Time)

#-----------------------------adu-----------------------------------------
outliers_malesHRMadu   <- Global_outliers(malesHRMadu_fd, Time)
outliers_malesWTadu    <- Global_outliers(malesWTadu_fd, Time)
outliers_femalesHRMadu   <- Global_outliers(femalesHRMadu_fd, Time)
outliers_femalesWTadu    <- Global_outliers(femalesWTadu_fd, Time)

#-----------------------------age-----------------------------------------
outliers_malesHRMage   <- Global_outliers(malesHRMage_fd, Time)
outliers_malesWTage    <- Global_outliers(malesWTage_fd, Time)
outliers_femalesWTage  <- Global_outliers(femalesWTage_fd, Time)
outliers_femalesHRMage <- Global_outliers(femalesHRMage_fd, Time)



plot_outliers <- function(fd_group, outliers_group, title, depth_col) {
  print(paste("Outliers for ", title, ":", outliers_group))  # indices
  
  matplot(Time,eval.fd(Time, fd_group), type = "l",lwd=2, col = "darkgray",
          main = title, xlab = "Time(sec)", ylab = "fESPS",
          ylim = range(eval.fd(Time, fd_group)))

  if (length(outliers_group) > 0) {
    matlines(Time,eval.fd(Time, fd_group)[, outliers_group], type = "l", col = depth_col)
  }

  #legend("topleft", legend = c("non outlier", "Outlier"),col = c("darkgray", "red"), lty = 1, lwd = c(1, 1),cex = 0.8,bty = "n")
}



#----------------------------------juv------------------------------------------
plot_outliers(malesWTjuv_fd, outliers_malesWTjuv, "Males WT Juvenile", depth_col="cyan3")
plot_outliers(malesHRMjuv_fd, outliers_malesHRMjuv, "Males HRM Juvenile", depth_col="royalblue" )

plot_outliers(femalesWTjuv_fd, outliers_femalesWTjuv, "Females WT Juvenile", depth_col= "magenta2")
plot_outliers(femalesHRMjuv_fd, outliers_femalesHRMjuv, "Females HRM Juvenile", depth_col= "darkviolet" )

#----------------------------------ado-----------------------------------------
plot_outliers(malesWTado_fd, outliers_malesWTado, "Males WT Adolescent", depth_col = "steelblue3" )
plot_outliers(malesHRMado_fd, outliers_malesHRMado, "Males HRM Adolescent", depth_col= "blue4" )

plot_outliers(femalesWTado_fd, outliers_femalesWTado, "Females WT Adolescent ", depth_col = "orchid" )
plot_outliers(femalesHRMado_fd, outliers_femalesHRMado, "Females HRM Adolescent", depth_col= "purple4")


#----------------------------------adu------------------------------------------
plot_outliers(malesWTadu_fd, outliers_malesWTadu, "Males WT Adult", depth_col="orange")
plot_outliers(malesHRMadu_fd, outliers_malesHRMadu, "Males HRM Adult", depth_col="orange4" )

plot_outliers(femalesWTadu_fd, outliers_femalesWTadu, "Females WT Adult", depth_col= "yellow2")
plot_outliers(femalesHRMadu_fd, outliers_femalesHRMadu, "Females HRM Adult", depth_col= "yellow4" )


#----------------------------------age-----------------------------------------
plot_outliers(malesWTage_fd, outliers_malesWTage, "Males WT Aged", depth_col = "green3" )
plot_outliers(malesHRMage_fd, outliers_malesHRMage, "Males HRM Aged", depth_col= "green4" )

plot_outliers(femalesWTage_fd, outliers_femalesWTage, "Females WT Aged ", depth_col = "red" )
plot_outliers(femalesHRMage_fd, outliers_femalesHRMage, "Females HRM Aged", depth_col= "red4")


```



## names and colors for mean group

```{r}

fd_groups <- list(
  malesWTjuv = cleaned_malesWTjuv$fd,
  malesHRMjuv = cleaned_malesHRMjuv$fd,
  femalesWTjuv = cleaned_femalesWTjuv$fd,
  femalesHRMjuv = cleaned_femalesHRMjuv$fd,
  
  malesWTado = cleaned_malesWTado$fd,
  malesHRMado = cleaned_malesHRMado$fd,
  femalesWTado = cleaned_femalesWTado$fd,
  femalesHRMado = cleaned_femalesHRMado$fd,
  
  malesWTadu = cleaned_malesWTadu$fd,
  malesHRMadu = cleaned_malesHRMadu$fd,
  femalesWTadu = cleaned_femalesWTadu$fd
  #femalesHRMadu=cleaned_femalesHRMadu$fd,
  
  #malesWTage= cleaned_malesWTage$fd,
  #malesHRMage=cleaned_malesHRMage$fd,
  #femalesWTage= cleaned_femalesWTage$fd,
  #femalesHRMage=cleaned_femalesHRMage$fd
)  

lty <- c(1,2,1,2,
         1,2,1,2,
         1,2,1
         #2,
         #1,2,1,2
         )


legends <- names(fd_groups)
```



## Mean function curves of each group.

plotting seperatly for males and females

```{r}

par(mar = c(5, 4, 4, 8))  

grid <- seq(min(Time), max(Time), length.out = 200)
mean_values_list <- lapply(fd_groups, function(fd_group) eval.fd(grid, mean.fd(fd_group)))
y_range <- range(unlist(mean_values_list))

plot(NULL, xlim = range(grid), ylim = y_range,
     xlab = "Time(sec)", ylab = "fEPSP",
     main = "Mean Functions")

for (i in seq_along(fd_groups)) {
  mean_fd <- mean.fd(fd_groups[[i]])
  mean_values <- eval.fd(grid, mean_fd)
  lines(grid, mean_values, col = colors[i], lwd = 2, lty =lty[i])
}

legend("topright", inset = c(-0.30, 0), xpd = TRUE,
       legend = legends, col = colors, lwd = 2, lty = lty, cex = 0.8, bty = "n")

grid()


```



## Covariance matrices 

```{r}
library(ggplot2)
library(reshape2)  # For melting matrix to long format


# Compute covariance matrices and store heatmaps
for (group_name in names(fd_groups)) {
  fd_group <- fd_groups[[group_name]]
  
  # Compute covariance function
  cov_fd <- var.fd(fd_group)
  
  # Evaluate the covariance matrix
  cov_matrix <- eval.bifd(Time, Time, cov_fd)
  
  # Convert to a long-format data frame for ggplot2
  cov_df <- melt(cov_matrix)
  colnames(cov_df) <- c("Time1", "Time2", "Covariance")
  
  # Create heatmap plot
  p <- ggplot(cov_df, aes(x = Time1, y = Time2, fill = Covariance)) +
    geom_tile() +
    scale_fill_gradientn(colors = heat.colors(100)) +
    labs(title = paste("Covariance Heatmap -", group_name), x = "Time(sec)", y = "Time(sec)") +
    theme_minimal()
  
  # Print the plot
  print(p)
}
par(mfrow = c(1, 1))




library(ggplot2)
library(reshape2)

cov_list <- list()  # stocker toutes les matrices de covariance

# Étape 1 : Calculer toutes les matrices sans les afficher
for (group_name in names(fd_groups)) {
  fd_group <- fd_groups[[group_name]]
  cov_fd <- var.fd(fd_group)
  cov_matrix <- eval.bifd(Time, Time, cov_fd)
  cov_list[[group_name]] <- cov_matrix
}

# Étape 2 : Trouver les limites globale min/max
global_min <- min(sapply(cov_list, min))
global_max <- max(sapply(cov_list, max))

cat("Limites globales :", global_min, global_max, "\n")

# Étape 3 : Créer les heatmaps avec la même échelle
for (group_name in names(cov_list)) {
  cov_matrix <- cov_list[[group_name]]
  cov_df <- melt(cov_matrix)
  colnames(cov_df) <- c("Time1", "Time2", "Covariance")
  
  p <- ggplot(cov_df, aes(x = Time1, y = Time2, fill = Covariance)) +
    geom_tile() +
    scale_fill_gradientn(
      colors = heat.colors(100),
      limits = c(global_min, global_max),   # <<–– Échelle commune
      oob = scales::squish                 # pour éviter warnings "outside scale"
    ) +
    labs(title = paste("Covariance Heatmap -", group_name),
         x = "Time(sec)", y = "Time(sec)") +
    theme_minimal()
  
  print(p)
}



```




## Variance function curves
+ plotting seperatly for males and females

```{r}

par(mar = c(5, 4, 4, 8))  
common_lambda <- result_common$lambda_opt 
common_basis  <- result_common$basis

var_values_list <- list()

for (i in seq_along(fd_groups)) {
  fd_group <- fd_groups[[i]]

  # covariance surface
  cov_fd <- var.fd(fd_group)
  
  # evaluate covariance matrix at all Time points
  cov_mat <- eval.bifd(Time, Time, cov_fd)
  
  # variance = diagonal of covariance matrix
  var_values <- diag(cov_mat)
  
  # smooth variance curve using common basis and lambda
  fdPar_var <- fdPar(common_basis, Lfdobj = 2, lambda = common_lambda)
  var_fd <- smooth.basis(Time, var_values, fdPar_var)$fd
  
  var_smooth_values <- eval.fd(Time, var_fd)
  
  var_values_list[[i]] <- var_smooth_values
}


# Plotting variance curves
y_range <- range(unlist(var_values_list), na.rm = TRUE)

plot(NULL, xlim = range(Time), ylim = y_range,
     xlab = "Time(sec)", ylab = "Variance of fEPSP",
     main = "Variance Functions")

for (i in seq_along(fd_groups)) {
  lines(Time, var_values_list[[i]], col = colors[i], lwd = 2,lty =lty[i])
}

legend("topright", inset = c(-0.30, 0), xpd = TRUE,
       legend = legends, col = colors, lwd = 2, lty = lty, cex = 0.8, bty = "n")

grid()

```




## kinetics/ Velocity: the mean first derivatives

```{r}



# to stock derivatives
all_derivs <- list()

for (i in seq_along(fd_groups)) {
  mean_fd <- mean.fd(fd_groups[[i]])
  deriv_fd <- deriv.fd(mean_fd)
  deriv_values <- eval.fd(Time, deriv_fd)
  all_derivs[[i]] <- deriv_values
}


ymin <- min(sapply(all_derivs, min))
ymax <- max(sapply(all_derivs, max))

# Plot 
for (i in seq_along(fd_groups)) {
  plot(
    Time, all_derivs[[i]], type = "l", col = colors[i], lwd = 3, lty = lty[i],
    xlab = "Time (sec)", ylab = "(fEPSP)'",
    main = paste("First Derivative -", legends[i]),
    ylim = c(ymin, ymax)   # <-- same scale
  )
  
  abline(h = 0, col = "red", lty = 2)
  grid()
}


```



## kinetics/ Acceleration: the mean second derivatives

```{r}


# to stock derivatives
all_second_derivs <- list()

for (i in seq_along(fd_groups)) {
  mean_fd <- mean.fd(fd_groups[[i]])
  deriv_fd <- deriv.fd(mean_fd)
  second_deriv_fd <- deriv.fd(deriv_fd)
  second_deriv_values <- eval.fd(Time, second_deriv_fd)
  all_second_derivs[[i]] <- second_deriv_values
}


ymin <- min(sapply(all_second_derivs, min))
ymax <- max(sapply(all_second_derivs, max))

# Plot 
for (i in seq_along(fd_groups)) {
  plot(
    Time, all_second_derivs[[i]], type = "l", col = colors[i], lwd = 3, lty = lty[i],
    xlab = "Time (sec)", ylab = "(fEPSP)'' ",
    main = paste("First Derivative -", legends[i]),
    ylim = c(ymin, ymax)   # <-- same scale
  )
  
  abline(h = 0, col = "red", lty = 2)
  grid()
}

```





## FPCA 

```{r}

group_names <- c( "Males HRM juv", "WT Males juv", "HRM Females juv", "WT Females juv", "HRM Males ado", "WT Males ado","HRM Females ado", "WT Females ado")
harmonics_list <- list()
scores_list <- list()

# Perform FPCA for each group (keep only 2 components)
for (i in 1:length(fd_groups)) {
  group_fpca <- pca.fd(fd_groups[[i]], nharm = 2)
  harmonics_list[[i]] <- eval.fd(Time, group_fpca$harmonics)  # First two PCs
  scores_list[[i]] <- group_fpca$scores[, 1:2]  # First two FPC scores
}

#plot 1st FPCs
par(mfrow = c(1, 2))  

for (i in 1:length(fd_groups)) {
  plot(Time, harmonics_list[[i]][, 1], type = "l", lwd = 2, col = colors[i],
       main = paste("First PC -", group_names[i]), xlab = "Time(sec)", ylab = "PC1")
  abline(h = 0, lty = 2)  
}

# Plot the 2ns FPCs 
par(mfrow = c(1, 2))  

for (i in 1:length(fd_groups)) {
  plot(Time, harmonics_list[[i]][, 2], type = "l", lwd = 2, col = colors[i],
       main = paste("Second PC -", group_names[i]), xlab = "Time(sec)", ylab = "PC2")
  abline(h = 0, lty = 2) 
}

# FPCA Scores 
par(mfrow = c(1, 2))  

for (i in 1:length(fd_groups)) {
  plot(scores_list[[i]], pch = 19, col = colors[i],
       main = paste("FPCA Scores -", group_names[i]),
       xlab = "FPC1 Scores", ylab = "FPC2 Scores")
  abline(h = 0, v = 0, lty = 2)  
}

# Reset layout to default
par(mfrow = c(1, 1))
```




##Amplitude Inference via Simultaneous Confidence Bands(SCBs) based bootstrap
Since there is random processes (bootstrapping, permutations, resampling), we set seeds.

```{r}
set.seed(1234)
Bootstrap_scb_difference <- function(fd_group1, fd_group2, n_bootstrap, Time) {
  n1 <- dim(fd_group1$coefs)[2]
  n2 <- dim(fd_group2$coefs)[2]

  # Observed mean curves
  mean_fd_group1 <- mean.fd(fd_group1)
  mean_fd_group2 <- mean.fd(fd_group2)
  mean_values_group1 <- eval.fd(Time, mean_fd_group1)
  mean_values_group2 <- eval.fd(Time, mean_fd_group2)
  diff_mean_values <- mean_values_group1 - mean_values_group2

  # Helper to compute and smooth variance via FPCA
  compute_variance_fd <- function(fd_group) {
    pca_result <- pca.fd(fd_group, nharm = 2)
    harmonics <- pca_result$harmonics
    eigenvalues <- pca_result$values
    harmvals <- eval.fd(Time, harmonics)
    var_fpca <- rowSums((harmvals^2) %*% diag(eigenvalues[1:2]))

    # Smooth the variance curve
    result_common_var <- Common_smoothing(list(matrix(var_fpca, ncol = 1)), Time, constraint = "none")
    eval.fd(Time, result_common_var$fd_list[[1]])
  }

  # Observed variance curves
  var_obs_group1 <- compute_variance_fd(fd_group1)
  var_obs_group2 <- compute_variance_fd(fd_group2)
  diff_var_obs <- sqrt(var_obs_group1 + var_obs_group2)
  
  # Compute observed supremum statistic
  Z_obs <- sqrt(n1 + n2) * diff_mean_values / diff_var_obs
  T_obs <- max(abs(Z_obs))
  

  # Initialize bootstrap supremums
  supremums <- numeric(n_bootstrap)

  for (b in seq_len(n_bootstrap)) {
    # 1) Resample smoothed curves with replacement
    idx1 <- sample(seq_len(n1), size = n1, replace = TRUE)
    idx2 <- sample(seq_len(n2), size = n2, replace = TRUE)
    resampled_fd1 <- fd(fd_group1$coefs[, idx1], fd_group1$basis)
    resampled_fd2 <- fd(fd_group2$coefs[, idx2], fd_group2$basis)

    # 2) Recompute bootstrap mean curves
    mean_fd1_b <- mean.fd(resampled_fd1)
    mean_fd2_b <- mean.fd(resampled_fd2)
    diff_mean_b <- eval.fd(Time, mean_fd1_b) - eval.fd(Time, mean_fd2_b)

    # 3) Re-estimate variance on bootstrap sample
    var_b_group1 <- compute_variance_fd(resampled_fd1)
    var_b_group2 <- compute_variance_fd(resampled_fd2)
    diff_var_b <- sqrt(var_b_group1 + var_b_group2)

    # 4) Form bootstrap root: standardized difference process
    Z_b <- sqrt(n1 + n2) * (diff_mean_b - diff_mean_values) / diff_var_b
    
    if (any(is.na(Z_b)) || any(is.infinite(Z_b))) {
      next  # Skip this replicate
    } else {
    supremums[b] <- max(abs(Z_b))
  }
}
  # Critical value for SCB (1 - alpha quantile)
  z_alpha <- quantile(supremums, 0.95)
  p_sup   <- (1 + sum(supremums >= T_obs)) / (n_bootstrap + 1)

  # Construct SCB around observed mean difference
  lower_bound <- diff_mean_values - (z_alpha * diff_var_obs) / sqrt(n1 + n2)
  upper_bound <- diff_mean_values + (z_alpha * diff_var_obs) / sqrt(n1 + n2)
  
  # Effect size
  effect_size_t <- diff_mean_values / diff_var_obs
  d_max <- max(abs(effect_size_t))
  d_mean <- mean(abs(effect_size_t))

  return(list(lower = lower_bound,
              upper = upper_bound,
              mean = diff_mean_values,
              sup_obs    = T_obs,
              sup_dist   = supremums,
              z_alpha    = z_alpha,
              p_value    = p_sup,
              d_t        = effect_size_t,
              d_max      = d_max,
              d_mean     = d_mean
              ))
}

```



##plots: Comparaison graphically and summary statistics.

```{r}

set.seed(1234)
# Specific group comparisons
specific_comp <- list(
  
  #comp between geno (sexe fix, age fix)
  c("malesHRMjuv", "malesWTjuv"),        #juv males
  c("femalesHRMjuv", "femalesWTjuv"),    #juv females
  
  c("malesHRMado", "malesWTado"),        #ado males
  c("femalesHRMado", "femalesWTado"),   #ado females
  
  c("malesHRMadu", "malesWTadu"),        #adu males
  c("femalesHRMadu", "femalesWTadu"),    #adu females
  
  c("malesHRMage", "malesWTage"),        #age males
  c("femalesHRMage", "femalesWTage"),    #age females
  
  
  
  
  # comp between dev stages (sexe fixe, geno fixe)
  
      #---------------Males-------------------------------
  
           # juv <--> ado
  c("malesHRMjuv", "malesHRMado"), #  HRM  
  c("malesWTjuv", "malesWTado"),   #  WT  
          # juv <--> adu
  c("malesHRMjuv", "malesHRMadu"), # HRM
  c("malesWTjuv", "malesWTadu"),   # WT
          # juv <--> age
  c("malesHRMjuv", "malesHRMage"), # HRM
  c("malesWTjuv", "malesWTage"),   # WT
  
  
  
          # ado <--> adu
  c("malesHRMado", "malesHRMadu"),  # HRM
  c("malesWTado", "malesWTadu"),    # WT
          # ado <--> age
  c("malesHRMadu", "malesHRMage"), # HRM
  c("malesWTadu", "malesWTage"),   # WT
  
  
           # adu <--> age
  c("malesHRMadu", "malesHRMage"),  #HRM
  c("malesWTadu", "malesWTage"),    #WT
  
  
  
  
    #--------------------Females--------------------------------
  

  
           # juv <--> ado
  c("femalesHRMjuv", "femalesHRMado"),      # females HRM  
  c("femalesWTjuv", "femalesWTado"),       # females WT  
          # juv <--> adu
  c("femalesHRMjuv", "femalesHRMadu"),     #females HRM
  c("femalesWTjuv", "femalesWTadu"),       #females WT
          # juv <--> age
  c("femalesHRMjuv", "femalesHRMage"),    #females HRM
  c("femalesWTjuv", "femalesWTage"),     #females WT
  
  
  
          # ado <--> adu
  c("femalesHRMado", "femalesHRMadu"),  #females HRM
  c("femalesWTado", "femalesWTadu"),    #females WT
          # ado <--> age
  c("femalesHRMadu", "femalesHRMage"),   #males HRM
  c("femalesWTadu", "femalesWTage"),      # males WT
  
  
           # adu <--> age
  c("femalesHRMadu", "femalesHRMage"),  #females HRM
  c("femalesWTadu", "femalesWTage"),    #females WT
  
  

  
  
  
)

# Store SCB results
scb_results <- list()

# Compute SCBs for each group pair
for (pair in specific_comp) {
  group1 <- pair[1]
  group2 <- pair[2]
  
  cat("Comparing:", group1, "vs", group2, "\n")
  
  result <- Bootstrap_scb_difference(
    fd_groups[[group1]], 
    fd_groups[[group2]], 
    n_bootstrap = 1000, 
    Time = Time
  )
  
  scb_results[[paste(group1, group2, sep = "_vs_")]] <- result
}

# Visualization


for (comparison in names(scb_results)) {
  scb_diff <- scb_results[[comparison]]
  
  plot(Time, scb_diff$mean, type = "l", col = "black", lwd = 2,
       ylim = range(c(scb_diff$lower, scb_diff$upper)),
       xlab = "Time((sec)", ylab = "fESPS",
       main = gsub("_", " ", comparison), cex.main = 1.1)
  
  lines(Time, scb_diff$lower, col = "blue", lty = 2)
  lines(Time, scb_diff$upper, col = "blue", lty = 2)
  abline(h = 0, col = "red", lty = 2)
  
  polygon(c(Time, rev(Time)), 
          c(scb_diff$lower, rev(scb_diff$upper)), 
          col = rgb(0.5,0.5,0,0.3), border = NA)
  
  
  legend("bottomright", legend = c("Mean Diff.", "95% SCB"), col = c("black", "blue"), 
         lwd = c(2, 1), lty = c(1, 2), cex = 0.7, bty = "n")
}

par(mfrow = c(1, 1))  # Reset layout



# Print summary stats for each group comparison
cat("\n--- SCB Summary Statistics for Each Comparison ---\n")
for (comparison in names(scb_results)) {
  res <- scb_results[[comparison]]
  cat("\nComparison:", gsub("_", " ", comparison), "\n")
  cat("  p-value:       ", round(res$p_value, 4), "\n")
  cat("  z_alpha:       ", round(res$z_alpha, 4), "\n")
  cat("  sup_obs:       ", round(res$sup_obs, 4), "\n")
  cat("  max|diff|:     ", round(max(abs(res$mean)), 4), "\n")
  cat("  max|effect|:   ", round(res$d_max, 4), "\n")
  cat("  mean|effect|:  ", round(res$d_mean, 4), "\n")
}

```



## Plots: Comparaison graphically and summary statistics at three phases


```{r}

intervalles <- list(Phase1 = seq(1, 360, length.out = 500),Phase2 = seq(361, 1740, length.out = 1000),Phase3 = seq(1741, 2399, length.out = 500))



scb_results <- list()


for (pair in specific_comp) {
  group1 <- pair[1]
  group2 <- pair[2]
  
  cat("Comparaison en cours :", group1, "vs", group2, "\n")
  
  scb_results[[paste(group1, group2, sep = "_vs_")]] <- list()
  
  for (phase in names(intervalles)) {
    Time <- intervalles[[phase]]
    
    #  SCB for each phase
    scb_results[[paste(group1, group2, sep = "_vs_")]][[phase]] <- Bootstrap_scb_difference(
      fd_groups[[group1]], 
      fd_groups[[group2]], 
      n_bootstrap = 1000, 
      Time = Time
    )
  }
}



par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))  

#Visualation
for (comparison in names(scb_results)) {
  for (phase in names(scb_results[[comparison]])) {
    scb_diff <- scb_results[[comparison]][[phase]]
    
    # 
    plot(intervalles[[phase]], scb_diff$mean, type = "l", col = "black", lwd = 2,
         ylim = range(c(scb_diff$lower, scb_diff$upper)),
         xlab = "Time(sec)", ylab = "fESPS",
         main = paste(gsub("_", " ", comparison), "-", phase), cex.main = 1.1)
    
    lines(intervalles[[phase]], scb_diff$lower, col = "blue", lty = 2)
    lines(intervalles[[phase]], scb_diff$upper, col = "blue", lty = 2)
    abline(h = 0, col = "red", lty = 2)
    
    polygon(c(intervalles[[phase]], rev(intervalles[[phase]])), 
            c(scb_diff$lower, rev(scb_diff$upper)), 
            col = rgb(0.5,0.5,0,0.3), border = NA)
    
    
    legend("bottomright", legend = c("Mean Diff.", "95% SCB"), col = c("black", "blue"), 
           lwd = c(2, 1), lty = c(1, 2), cex = 0.7, bty = "n")
  }
}


par(mfrow = c(1, 1))
```

```{r}
# ---- Define Phase Intervals ----
intervalles <- list(
  Phase1 = seq(1, 360, length.out = 500),
  Phase2 = seq(361, 1740, length.out = 1000),
  Phase3 = seq(1741, 2399, length.out = 500)
)

# ---- Automatically Trim Time to Basis Range ----
# Get valid time range from any fd object (assuming all share same basis)
range_basis <- fd_groups[["malesHRMjuv"]]$basis$rangeval  # or any valid group name

# Trim each phase's time values to ensure they fall within the basis range
for (phase in names(intervalles)) {
  intervalles[[phase]] <- intervalles[[phase]][
    intervalles[[phase]] >= range_basis[1] &
    intervalles[[phase]] <= range_basis[2]
  ]
}

# ---- Define Group Comparisons ----
specific_comp <- list(
  c("malesHRMjuv", "malesWTjuv"),
  c("femalesHRMjuv", "femalesWTjuv"),
  c("malesHRMado", "malesWTado"),
  c("femalesHRMado", "femalesWTado"),
  c("malesHRMjuv", "malesHRMado"),
  c("femalesHRMjuv", "femalesHRMado"),
  c("malesWTjuv", "malesWTado"),
  c("femalesWTjuv", "femalesWTado")
)

# ---- Compute SCB Results ----
scb_results <- list()

for (pair in specific_comp) {
  group1 <- pair[1]
  group2 <- pair[2]
  
  cat("Comparaison en cours :", group1, "vs", group2, "\n")
  comparison_name <- paste(group1, group2, sep = "_vs_")
  scb_results[[comparison_name]] <- list()
  
  for (phase in names(intervalles)) {
    Time <- intervalles[[phase]]
    
    # SCB computation
    scb_results[[comparison_name]][[phase]] <- Bootstrap_scb_difference(
      fd_groups[[group1]],
      fd_groups[[group2]],
      n_bootstrap = 1000,
      Time = Time
    )
  }
}

# ---- Plot Results ----
par(mfrow = c(2, 3), mar = c(4, 4, 2, 1))  # 2 rows, 3 plots per row

for (comparison in names(scb_results)) {
  for (phase in names(scb_results[[comparison]])) {
    scb_diff <- scb_results[[comparison]][[phase]]
    Time <- intervalles[[phase]]
    
    plot(Time, scb_diff$mean, type = "l", col = "black", lwd = 2,
         ylim = range(c(scb_diff$lower, scb_diff$upper), na.rm = TRUE),
         xlab = "Time(sec)", ylab = "fESPS",
         main = paste(gsub("_", " ", comparison), "-", phase), cex.main = 1.1)
    
    lines(Time, scb_diff$lower, col = "blue", lty = 2)
    lines(Time, scb_diff$upper, col = "blue", lty = 2)
    abline(h = 0, col = "red", lty = 2)
    
    polygon(c(Time, rev(Time)),
            c(scb_diff$lower, rev(scb_diff$upper)),
            col = rgb(0.5, 0.5, 0, 0.3), border = NA)
    
    legend("bottomright", legend = c("Mean Diff.", "95% SCB"),
           col = c("black", "blue"), lwd = c(2, 1), lty = c(1, 2), cex = 0.7, bty = "n")
  }
}

par(mfrow = c(1, 1))  # Reset layout




cat("\n--- SCB Summary Statistics for Each Comparison by Phase ---\n")

for (comparison in names(scb_results)) {
  cat("\nComparison:", gsub("_", " ", comparison), "\n")
  
  for (phase in names(scb_results[[comparison]])) {
    res <- scb_results[[comparison]][[phase]]
    
    cat("  Phase:", phase, "\n")
    cat("    p-value:       ", round(res$p_value, 4), "\n")
    cat("    z_alpha:       ", round(res$z_alpha, 4), "\n")
    cat("    sup_obs:       ", round(res$sup_obs, 4), "\n")
    cat("    max|diff|:     ", round(max(abs(res$mean), na.rm = TRUE), 4), "\n")
    cat("    max|effect|:   ", round(res$d_max, 4), "\n")
    cat("    mean|effect|:  ", round(res$d_mean, 4), "\n")
  }
}

```





##Functional ANOVA: 2 factors



```{r}
set.seed(1234)


#--- two-way functional ANOVA with permutation test & effect sizes ---#
fanova2_FP <- function(fd_list, factorA, factorB, P = 2000, parallel = FALSE) {
  
  # 1) Input checks and coefficient extraction
  stopifnot(length(fd_list) == length(factorA),
            length(factorA) == length(factorB))
  
  coefs_list <- lapply(fd_list, function(fdi) fdi$coefs)  
  ns <- sapply(coefs_list, ncol)
  coef_mat  <- do.call(cbind, coefs_list)   # K ? N
  coefs_NK  <- t(coef_mat)                  # N ? K
  
  # 2) Build full factor labels
  factorA_all <- factor(rep(factorA, times = ns))
  factorB_all <- factor(rep(factorB, times = ns))
  
  # 3) Helper to compute sums of squares and F-stats
  compute_stats <- function(coefs, A, B) {
    N   <- nrow(coefs)
    levA <- levels(A); a <- length(levA)
    levB <- levels(B); b <- length(levB)
    
    # Grand and group means
    grand.mean <- colMeans(coefs)
    meansA     <- t(sapply(levA, function(l) colMeans(coefs[A==l,,drop=FALSE])))
    meansB     <- t(sapply(levB, function(l) colMeans(coefs[B==l,,drop=FALSE])))
    
    # Interaction means
    meansAB <- array(0, dim = c(a, b, ncol(coefs)))
    for(i in seq_len(a)) for(j in seq_len(b)) {
      sel <- which(A==levA[i] & B==levB[j])
      if(length(sel)>0) meansAB[i,j,] <- colMeans(coefs[sel,,drop=FALSE])
    }
    
    # Sums of squares
    SSA <- sum(sapply(seq_len(a), function(i) {
      ni <- sum(A==levA[i])
      ni * sum((meansA[i,] - grand.mean)^2)
    }))
    SSB <- sum(sapply(seq_len(b), function(j) {
      nj <- sum(B==levB[j])
      nj * sum((meansB[j,] - grand.mean)^2)
    }))
    SSAB <- sum(sapply(seq_len(a), function(i) {
      sapply(seq_len(b), function(j) {
        nij   <- sum(A==levA[i] & B==levB[j])
        delta <- meansAB[i,j,] - meansA[i,] - meansB[j,] + grand.mean
        nij * sum(delta^2)
      })
    }))
    
    # SSE (residual)
    fitted   <- matrix(0, nrow = N, ncol = ncol(coefs))
    for(k in seq_len(N)) {
      i <- which(levA == A[k]); j <- which(levB == B[k])
      fitted[k,] <- meansAB[i,j,]
    }
    residuals <- coefs - fitted
    SSE <- sum(residuals^2)
    
    # Degrees of freedom
    dfA <- a - 1; dfB <- b - 1; dfAB <- (a-1)*(b-1); dfE <- N - a*b
    
    # Mean squares and F-stats
    MSA  <- SSA / dfA; MSB  <- SSB / dfB
    MSAB <- SSAB/ dfAB; MSE  <- SSE / dfE
    FA   <- MSA / MSE;   FB   <- MSB / MSE
    FAB  <- MSAB/ MSE
    
    list(
      SSA  = SSA,
      SSB  = SSB,
      SSAB = SSAB,
      SSE  = SSE,
      F    = c(FA = FA, FB = FB, FAB = FAB),
      df   = c(A = dfA, B = dfB, AB = dfAB, E = dfE)
    )
  }
  
  # 4) Observed statistics
  obs <- compute_stats(coefs_NK, factorA_all, factorB_all)
  
  # 5) Effect-size calculations (eta-squared)
  SST <- obs$SSA + obs$SSB + obs$SSAB + obs$SSE
  eta2_A  <- obs$SSA  / SST
  eta2_B  <- obs$SSB  / SST
  eta2_AB <- obs$SSAB / SST
  
  
  
  
  
  # 6)build the null distributions of F-values by shuffling the labels and recalculating the F-statistics each time. That's what this loop does.
  permF_A  <- numeric(P) #to store the F-values from each permutation
  permF_B  <- numeric(P)
  permF_AB <- numeric(P)
  for(p in seq_len(P)) {
    permA <- sample(factorA_all)
    permB <- sample(factorB_all)
    st <- compute_stats(coefs_NK, permA, permB)$F
    permF_A[p]  <- st["FA"]
    permF_B[p]  <- st["FB"]
    permF_AB[p] <- st["FAB"]
  }
  
  # 7) Permutation p-values
  pA  <- (1 + sum(permF_A  >= obs$F["FA"]))  / (P + 1)
  pB  <- (1 + sum(permF_B  >= obs$F["FB"]))  / (P + 1)
  pAB <- (1 + sum(permF_AB >= obs$F["FAB"])) / (P + 1)
  
  # 8) Return all results
  return(list(
    stat         = obs$F,
    df           = obs$df,
    pvalue       = c(pA = pA, pB = pB, pAB = pAB),
    perm         = list(FA = permF_A, FB = permF_B, FAB = permF_AB),
    effect_size_eta  = c(eta2_A  = eta2_A,eta2_B  = eta2_B,eta2_AB = eta2_AB)
   
  ))
}
```


## Plots: factors sexe and  genotype

```{r}
set.seed(1234)
#------------------- USAGE -------------------#

# define your two factors (length = 4, matching the list order)
sex <- c("M","M","F","F",
         "M","M","F","F",
         "M","M","F","F",
         "M","M","F","F")

genotype <- c("HRM","WT","HRM","WT",
              "HRM","WT","HRM","WT",
              "HRM","WT","HRM","WT",
              "HRM","WT","HRM","WT")

# Suppose fd_groups, genotype, and age are already defined:
res3 <- fanova2_FP(fd_groups, sex, genotype, P = 2000)

# Inspect results:
fstat3<-res3$stat      # observed F?s for A, B, AB
pvalue3<- res3$pvalue    # permutation p-values
df3<- res3$df
effectsize_eta3 <- res3$effect_size_eta



anova_table <- data.frame(
  Factor = c("sex","genotype","sex:genotype"),
  F_stat = c(fstat3[1], fstat3[2], fstat3[3]),
  p_value = c(pvalue3[1], pvalue3[2], pvalue3[3]),
  df = c(df3[1], df3[2], df3[3]),
  eff_size_eta = c(effectsize_eta3[1],effectsize_eta3[2],effectsize_eta3[3])
  
)
print(anova_table)

```


##Functional ANOVA : 3 factors

```{r}
set.seed(1234)


#-------------------------------------------------------------------------------
#----------- three-way functional ANOVA (on basis coefficients) ---------------
#-----------         with permutation-based p-values                     -------
#-------------------------------------------------------------------------------

fanova3_FP <- function(fd_list, factorG, factorA, factorS, P = 1000, parallel = FALSE) {
  # fd_list:   a list of 'fd' objects (each has a $coefs matrix of size K?n_i)
  # factorG:   a factor (length = length(fd_list)) giving the "G" level of each group
  # factorA:   a factor (length = length(fd_list)) giving the "A" level of each group
  # factorS:   a factor (length = length(fd_list)) giving the "S" level of each group
  # P:         number of permutations to run (default = 1000)
  # parallel:  (not used here, but included for consistency with your two-way code)
  
  # 1) Input checks and coefficient extraction
  stopifnot(length(fd_list) == length(factorG),
            length(factorG) == length(factorA),
            length(factorA) == length(factorS))
  
  # Extract each fd_i's coefficient matrix (K ? n_i), then build one big (K ? N) matrix
  coefs_list <- lapply(fd_list, function(fdi) fdi$coefs)  
  ns         <- sapply(coefs_list, ncol)   # ns[i] = number of columns in coefs_list[[i]]
  coef_mat   <- do.call(cbind, coefs_list) # K ? N  (columns of each group bound side by side)
  coefs_NK   <- t(coef_mat)                # N ? K  (each row = one ?replicate?'s K-vector of basis-coefs)
  
  # 2) Build the ?full-length? factor vectors of length N
  G_all <- factor(rep(factorG, times = ns))
  A_all <- factor(rep(factorA, times = ns))
  S_all <- factor(rep(factorS, times = ns))
  
  # 3) A helper function to compute SS, F, and df for all seven effects
  compute_stats3 <- function(coefs, G, A, S) {
    # coefs: N ? K matrix
    # G, A, S: each is a factor of length N
    N    <- nrow(coefs)
    levG <- levels(G); g <- length(levG)
    levA <- levels(A); a <- length(levA)
    levS <- levels(S); s <- length(levS)
    
    # 3.1) Grand mean (length K)
    mu0 <- colMeans(coefs)  # a K-vector
    
    # 3.2) Main-effect means (each is ?levels ? K?)
    muG <- t(sapply(levG, function(l) colMeans(coefs[G == l, , drop = FALSE])))
    muA <- t(sapply(levA, function(l) colMeans(coefs[A == l, , drop = FALSE])))
    muS <- t(sapply(levS, function(l) colMeans(coefs[S == l, , drop = FALSE])))
    
    # 3.3) Two-way interaction means (each array has dimension [levels1, levels2, K])
    muGA <- array(0, dim = c(g, a, ncol(coefs)))
    for (i in seq_len(g)) {
      for (j in seq_len(a)) {
        sel <- which(G == levG[i] & A == levA[j])
        if (length(sel) > 0) {
          muGA[i, j, ] <- colMeans(coefs[sel, , drop = FALSE])
        }
      }
    }
    
    muGS <- array(0, dim = c(g, s, ncol(coefs)))
    for (i in seq_len(g)) {
      for (k in seq_len(s)) {
        sel <- which(G == levG[i] & S == levS[k])
        if (length(sel) > 0) {
          muGS[i, k, ] <- colMeans(coefs[sel, , drop = FALSE])
        }
      }
    }
    
    muAS <- array(0, dim = c(a, s, ncol(coefs)))
    for (j in seq_len(a)) {
      for (k in seq_len(s)) {
        sel <- which(A == levA[j] & S == levS[k])
        if (length(sel) > 0) {
          muAS[j, k, ] <- colMeans(coefs[sel, , drop = FALSE])
        }
      }
    }
    
    # 3.4) Three-way interaction mean [g ? a ? s ? K]
    muGAS <- array(0, dim = c(g, a, s, ncol(coefs)))
    for (i in seq_len(g)) {
      for (j in seq_len(a)) {
        for (k in seq_len(s)) {
          sel <- which(G == levG[i] & A == levA[j] & S == levS[k])
          if (length(sel) > 0) {
            muGAS[i, j, k, ] <- colMeans(coefs[sel, , drop = FALSE])
          }
        }
      }
    }
    
    # 4) Compute sums-of-squares (as scalars) for each effect
    SSG <- sum(sapply(seq_len(g), function(i) {
      ni <- sum(G == levG[i])
      sum((muG[i, ] - mu0)^2) * ni
    }))
    SSA <- sum(sapply(seq_len(a), function(j) {
      nj <- sum(A == levA[j])
      sum((muA[j, ] - mu0)^2) * nj
    }))
    SSS <- sum(sapply(seq_len(s), function(k) {
      nk <- sum(S == levS[k])
      sum((muS[k, ] - mu0)^2) * nk
    }))
    
    SSAG <- sum(sapply(seq_len(g), function(i) {
      sapply(seq_len(a), function(j) {
        nij <- sum(G == levG[i] & A == levA[j])
        sum((muGA[i, j, ] - muG[i, ] - muA[j, ] + mu0)^2) * nij
      })
    }))
    
    SSGS <- sum(sapply(seq_len(g), function(i) {
      sapply(seq_len(s), function(k) {
        nig <- sum(G == levG[i] & S == levS[k])
        sum((muGS[i, k, ] - muG[i, ] - muS[k, ] + mu0)^2) * nig
      })
    }))
    
    SSAS <- sum(sapply(seq_len(a), function(j) {
      sapply(seq_len(s), function(k) {
        naj <- sum(A == levA[j] & S == levS[k])
        sum((muAS[j, k, ] - muA[j, ] - muS[k, ] + mu0)^2) * naj
      })
    }))
    
    SSGAS <- sum(sapply(seq_len(g), function(i) {
      sapply(seq_len(a), function(j) {
        sapply(seq_len(s), function(k) {
          nijk <- sum(G == levG[i] & A == levA[j] & S == levS[k])
          delta <- muGAS[i, j, k, ] -
                   muGA[i, j, ]   - muGS[i, k, ]   - muAS[j, k, ] +
                   muG[i, ]       + muA[j, ]       + muS[k, ]   -
                   mu0
          sum(delta^2) * nijk
        })
      })
    }))
    
    # 5) Fit-and-residual (same pattern as 2-way code)
    fitted <- matrix(0, nrow = N, ncol = ncol(coefs))
    for (n in seq_len(N)) {
      i <- which(levG == G[n])
      j <- which(levA == A[n])
      k <- which(levS == S[n])
      fitted[n, ] <- muGAS[i, j, k, ]
    }
    residuals <- coefs - fitted
    SSE <- sum(residuals^2)
    
    # 6) Degrees of freedom
    dfG   <- g - 1
    dfA   <- a - 1
    dfS   <- s - 1
    dfAG  <- dfG * dfA
    dfGS  <- dfG * dfS
    dfAS  <- dfA * dfS
    dfGAS <- dfG * dfA * dfS
    dfE   <- N - (g * a * s)
    
    # 7) Mean squares and F-statistics
    MSE   <- SSE / dfE
    FG    <- (SSG  / dfG)   / MSE
    FA    <- (SSA  / dfA)   / MSE
    FS    <- (SSS  / dfS)   / MSE
    FAG   <- (SSAG / dfAG)  / MSE
    FGS   <- (SSGS / dfGS)  / MSE
    FAS   <- (SSAS / dfAS)  / MSE
    FGAS  <- (SSGAS / dfGAS) / MSE
    
    list(
      SSG   = SSG,
      SSA   = SSA,
      SSS   = SSS,
      SSAG  = SSAG,
      SSGS  = SSGS,
      SSAS  = SSAS,
      SSGAS = SSGAS,
      SSE   = SSE,
      FF    = c(FG = FG, FA = FA, FS = FS, FAG = FAG, FGS = FGS, FAS = FAS, FGAS = FGAS),
      df    = c(dfG = dfG, dfA = dfA, dfS = dfS, dfAG = dfAG, dfGS = dfGS, dfAS = dfAS, dfGAS = dfGAS, dfE = dfE)
    )
  }
  
  # 4) Observe the ?true? statistics on the original grouping
  obs <- compute_stats3(coefs_NK, G_all, A_all, S_all)
  
  # 5) Compute effect-sizes ??? for each effect
  SST <- obs$SSG + obs$SSA + obs$SSS + obs$SSAG + obs$SSGS + obs$SSAS + obs$SSGAS + obs$SSE
  eta2_G   <- obs$SSG   / SST
  eta2_A   <- obs$SSA   / SST
  eta2_S   <- obs$SSS   / SST
  eta2_AG  <- obs$SSAG  / SST
  eta2_GS  <- obs$SSGS  / SST
  eta2_AS  <- obs$SSAS  / SST
  eta2_GAS <- obs$SSGAS / SST
  
  # 6) Permutation loop to build null distributions for each F-statistic
  permF_G   <- numeric(P)
  permF_A   <- numeric(P)
  permF_S   <- numeric(P)
  permF_AG  <- numeric(P)
  permF_GS  <- numeric(P)
  permF_AS  <- numeric(P)
  permF_GAS <- numeric(P)
  
  for (p in seq_len(P)) {
    permG <- sample(G_all)
    permA <- sample(A_all)
    permS <- sample(S_all)
    
    st <- compute_stats3(coefs_NK, permG, permA, permS)$FF
    permF_G[p]   <- st["FG"]
    permF_A[p]   <- st["FA"]
    permF_S[p]   <- st["FS"]
    permF_AG[p]  <- st["FAG"]
    permF_GS[p]  <- st["FGS"]
    permF_AS[p]  <- st["FAS"]
    permF_GAS[p] <- st["FGAS"]
  }
  
  # 7) Permutation-based p-values
  pG   <- (1 + sum(permF_G   >= obs$FF["FG"]))   / (P + 1)
  pA   <- (1 + sum(permF_A   >= obs$FF["FA"]))   / (P + 1)
  pS   <- (1 + sum(permF_S   >= obs$FF["FS"]))   / (P + 1)
  pAG  <- (1 + sum(permF_AG  >= obs$FF["FAG"]))  / (P + 1)
  pGS  <- (1 + sum(permF_GS  >= obs$FF["FGS"]))  / (P + 1)
  pAS  <- (1 + sum(permF_AS  >= obs$FF["FAS"]))  / (P + 1)
  pGAS <- (1 + sum(permF_GAS >= obs$FF["FGAS"])) / (P + 1)
  
  # 8) Return a list of observed stats, dfs, p-values, permutations, and ???
  list(
    stat            = obs$FF,
    df              = obs$df,
    pvalue          = c(pG = pG, pA = pA, pS = pS, pAG = pAG, pGS = pGS, pAS = pAS, pGAS = pGAS),
    perm            = list(FG = permF_G, FA = permF_A, FS = permF_S,
                           FAG = permF_AG, FGS = permF_GS, FAS = permF_AS, FGAS = permF_GAS),
    effect_size_eta = c(eta2_G = eta2_G, eta2_A = eta2_A, eta2_S = eta2_S,
                        eta2_AG = eta2_AG, eta2_GS = eta2_GS, eta2_AS = eta2_AS, eta2_GAS = eta2_GAS)
  )
}
```



## Plots: factors sexe, genotype, age

```{r}
set.seed(1234)
#---------------------- USAGE EXAMPLE ----------------------#
# Suppose having n functional observations (each in fd_groups[[i]]).  we define:
geno <- c("HRM","WT","HRM","WT", 
          "HRM","WT","HRM","WT",
          "HRM","WT","HRM","WT", 
          "HRM","WT","HRM","WT")

age  <- c("juv","juv","juv","juv",
          "ado","ado","ado","ado", 
          "adu", "adu","adu", "adu",
          "age","age","age","age")

sexe <- c("M","M","F","F",
          "M","M","F","F",
          "M","M","F","F",
          "M","M","F","F")

# Runing the 3-way functional ANOVA (with 2 000 permutations):
res3 <- fanova3_FP(fd_groups, geno, age, sexe, P = 2000)

# Extracting results:
fstats     <- res3$stat       # FG, FA, FS, FAG, FGS, FAS, FGAS
pvals      <- res3$pvalue
dfs        <- res3$df
eta2       <- res3$effect_size_eta

# Building a small ANOVA table:
anova_table3 <- data.frame(
  Factor      = c("geno","age","sexe","geno:age","geno:sexe","age:sexe","geno:age:sexe"),
  F_stat      = c(fstats["FG"],    fstats["FA"],    fstats["FS"],
                  fstats["FAG"],   fstats["FGS"],   fstats["FAS"],
                  fstats["FGAS"]),
  p_value     = c(pvals["pG"],     pvals["pA"],     pvals["pS"],
                  pvals["pAG"],    pvals["pGS"],    pvals["pAS"],
                  pvals["pGAS"]),
  df_numer    = c(dfs["dfG"],      dfs["dfA"],      dfs["dfS"],
                  dfs["dfAG"],     dfs["dfGS"],     dfs["dfAS"],
                  dfs["dfGAS"]),
  #df_denom    = rep(dfs["dfE"], 7),
  eta2_effect = c(eta2["eta2_G"],  eta2["eta2_A"],  eta2["eta2_S"],
                  eta2["eta2_AG"], eta2["eta2_GS"], eta2["eta2_AS"],
                  eta2["eta2_GAS"])
)

print(anova_table3)

```








































































