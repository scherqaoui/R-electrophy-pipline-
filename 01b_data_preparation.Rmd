---
title: "data smoothing"
output: html_document
date: "2025-11-20"
---



```{r fd data}

library(fda)
library(fda.usc)
library(fdANOVA)
library(rmarkdown)


rmarkdown::render("01a_data_preparation.Rmd", envir = globalenv(), quiet = TRUE)

Common_smoothing <- function(all_data_groups, Time) {

  # --------------- 0. all data ---------------
  all_data_combined <- do.call(cbind, all_data_groups)
  y_mean_raw <- rowMeans(all_data_combined, na.rm = TRUE)

  
  grid <- seq(min(Time), max(Time), length.out = 500)

  # ---------------- 1. preliminary smoothing to the global signal  ----------------
  # Pre-smoothing : to compute knots
  basis_tmp <- create.bspline.basis(range(Time), nbasis = 4, norder = 4)
  fdPar_tmp <- fdPar(basis_tmp, Lfdobj = 2, lambda = 8)
  smooth_tmp <- smooth.basis(Time, y_mean_raw, fdPar_tmp)$fd
  y_mean_smooth <- eval.fd(Time, smooth_tmp)

  # ---------------- 2. Knots estimation  ----------------
  dy  <- diff(y_mean_smooth) / diff(Time)
  d2y <- diff(dy) / diff(Time[-1])

  w <- abs(d2y)
  w <- w / sum(w)

  nbasis <- 12       
  norder <- 4
  nbreaks <- nbasis - norder + 2

  cumw <- cumsum(w) / sum(w)
  quant <- seq(0, 1, length.out = nbreaks + 2)[-c(1, nbreaks + 2)]
  id <- sapply(quant, function(q) which.min(abs(cumw - q)))

  breaks <- unique(c(min(Time), Time[id], max(Time)))

  basis <- create.bspline.basis(range(Time), norder = norder, breaks = breaks)

  # ---------------- 3. Lambda selection via GCV----------------
  lambda_values <- 10^seq(-1, 3, length.out = 500)

  gcv <- sapply(lambda_values, function(lambda) {
    fdP <- fdPar(basis, Lfdobj = 2, lambda = lambda)
    sm <- smooth.basis(Time, y_mean_smooth, fdP)
    mean(sm$gcv, na.rm = TRUE)
  })

  #  GCV smoothing, opt lambda
  gcv_smoothed <- stats::smooth.spline(log10(lambda_values), gcv, spar = 0.6)$y

  lambda_opt <- lambda_values[ which.min(gcv_smoothed) ]


  # ---------------- 4. Final smoothing of each curve ----------------
  fd_list <- lapply(all_data_groups, function(group) {

    coef_list <- lapply(seq_len(ncol(group)), function(k) {
      y_interp <- approx(Time, group[, k], xout = grid)$y
      fdP <- fdPar(basis, Lfdobj = 2, lambda = lambda_opt)
      smooth.basis(grid, y_interp, fdP)$fd$coefs
    })

    coefs <- do.call(cbind, coef_list)
    fd(coefs, basis)
  })


  
  return(list(
    fd_list = fd_list,
    basis = basis,
    grid = grid,
    lambda_opt = lambda_opt,
    gcv = gcv,
    gcv_smoothed = gcv_smoothed,
    lambda_values = lambda_values,
    breaks = breaks
  ))
}


# applying the common smoothing
result_common <- Common_smoothing(all_groups, Time)


# A named list of fd objects, one per group
all_fd_groups <- setNames(result_common$fd_list, groups_names)


```







